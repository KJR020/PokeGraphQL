You are an expert in TypeScript, Node.js, Nuxt 3, Vue 3, Vuetify, GraphQL, Apollo, and Sass.

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use composition API and declarative programming patterns; avoid options API.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, composables, helpers, static content, types.

## Naming Conventions

- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Use PascalCase for component names (e.g., AuthWizard.vue).
- Use camelCase for composables (e.g., useAuthState.ts).

## TypeScript Usage

- Use TypeScript for all code; prefer types over interfaces.
- Avoid enums; use const objects instead.
- Use Vue 3 with TypeScript, leveraging defineComponent and PropType.

## Syntax and Formatting

- Use arrow functions for methods and computed properties.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use template syntax for declarative rendering.

## UI and Styling

- Follow Vuetify design patterns and component usage guidelines.
- Implement responsive design using Vuetify's grid system and breakpoints.
- Use Sass for custom styling when needed.
- Follow BEM methodology for custom CSS classes.

## Performance Optimization

- Leverage Nuxt's built-in performance optimizations.
- Use Suspense for asynchronous components.
- Implement lazy loading for routes and components.
- Optimize images: use WebP format, include size data, implement lazy loading.

## Key Conventions

- Use Pinia for state management when needed.
- Optimize Web Vitals (LCP, CLS, FID).
- Utilize Nuxt's auto-imports feature for components and composables.
- Follow GraphQL best practices for queries and mutations.
- Use Apollo Client efficiently for data management.

## Nuxt-specific Guidelines

- Follow Nuxt 3 directory structure (e.g., pages/, components/, composables/).
- Use Nuxt's built-in features:
  - Auto-imports for components and composables.
  - File-based routing in the pages/ directory.
  - Server routes in the server/ directory.
  - Leverage Nuxt plugins for global functionality.
- Use useFetch and useAsyncData for data fetching.
- Implement SEO best practices using Nuxt's useHead and useSeoMeta.

## Vue 3 and Composition API Best Practices

- Use <script setup> syntax for concise component definitions.
- Leverage ref, reactive, and computed for reactive state management.
- Use provide/inject for dependency injection when appropriate.
- Implement custom composables for reusable logic.

## Testing Guidelines

- Write unit tests using Vitest for components and utilities.
- Use Vue Test Utils for component testing.
- Follow the AAA (Arrange, Act, Assert) pattern in tests.
- Mock external dependencies and Apollo queries in tests.
- Aim for meaningful test coverage of critical functionality.

## GraphQL and Apollo Integration

- Organize queries and mutations in separate files under the queries/ directory.
- Use GraphQL fragments for reusable query parts.
- Implement proper error handling for GraphQL operations.
- Utilize Apollo Client's caching capabilities effectively.
- Follow naming conventions for queries, mutations, and fragments.

## Sass Usage

- Use Sass variables for consistent theming.
- Implement mixins for reusable styles.
- Follow a modular approach to styling.
- Use nesting appropriately without excessive depth.
- Maintain a clean and organized structure for style files.

Follow the official documentation for Nuxt.js, Vue.js, Vuetify, GraphQL, and Apollo for up-to-date best practices on Data Fetching, Rendering, and Routing.